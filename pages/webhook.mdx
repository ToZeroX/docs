---
title: 'Webhook介绍'
---

## Webhook说明

| 机制           | 描述    | 触发条件 | 响应                                                                                    |
|:-----------------|:---------|:----------|:------------------------------------------------------------------------------------------|
| Webhook         | 用作事件的实时通知，例如交易状态更新。  | 当某些事件发生时触发，例如交易状态或 TSS 请求状态更改，基于您订阅的事件类型。       | 以成功状态码（<code>200</code> 或 <code>201</code>）响应。                                                    |

<Note>
  需要在webhook的处理中，判断一下事件中的wallet_id是否为您的wallet_id，如果不是，则忽略。
</Note>

## 处理 webhook 事件

1. 创建一个 webhook
    - 选择服务器环境。
    - 定义Endpoint URL。
2. 在服务器端实现处理逻辑。
    - 解析 API 请求。
    - 验证签名。
    - 响应 API 请求。
    - 添加其他处理逻辑（如果适用）。
3. 将webhook地址提供给我们，由我们来进行配置(暂时)

## 验证签名

为了防止未经授权的访问，当您收到 Webhook 事件时，您需要通过验证签名来验证 API 请求的真实性。

1. 获取请求包体的原始数据和时间戳。 从请求 Payload 中提取包体的原始字符串，并从请求头中提取时间戳。

<CodeGroup>
``` go title="Go"
bizTimestamp := r.Header.Get("biz-timestamp")
```

``` javascript title="Node.js"
const bizTimestamp = req.headers['biz-timestamp'];
```
</CodeGroup>

2. 获取签名， 从请求头中获取签名值。

<CodeGroup>
``` go title="Go"
signature := r.Header.Get("biz-resp-signature")
```

``` javascript title="Node.js"
const signature = req.headers['biz-resp-signature'];
```
</CodeGroup>

3. 拼接消息并对其进行哈希处理，使用相应的公钥进行验证：

<CodeGroup>
``` go title="Go"
package webhook

import (
	"crypto/sha256"
	"encoding/hex"
	"errors"

	"golang.org/x/crypto/ed25519"
)

func doubleSHA256Hex(message string) ([]byte, error) {
	h1 := sha256.Sum256([]byte(message))
	h2 := sha256.Sum256(h1[:])

	return h2[:], nil
}

func VerifySignature(rawBody string, bizTimestamp string, signatureHex string, pubKeyHex string) (bool, error) {
	if bizTimestamp == "" || signatureHex == "" {
		return false, errors.New("missing signature or timestamp")
	}

	msg := rawBody + "|" + bizTimestamp

	msgHash, err := doubleSHA256Hex(msg)
	if err != nil {
		return false, err
	}

	sig, err := hex.DecodeString(signatureHex)
	if err != nil {
		return false, err
	}

	pubKeyBytes, err := hex.DecodeString(pubKeyHex)
	if err != nil {
		return false, err
	}

	// pubKey 必须是 32 bytes
	if l := len(pubKeyBytes); l != ed25519.PublicKeySize {
		return false, errors.New("invalid pubkey length, must be 32 bytes (ed25519)")
	}
	if l := len(sig); l != ed25519.SignatureSize {
		return false, errors.New("invalid signature length, must be 64 bytes (ed25519)")
	}

	ok := ed25519.Verify(ed25519.PublicKey(pubKeyBytes), msgHash, sig)
	return ok, nil
}
```

``` javascript title="Node.js"
const CryptoJS = require('ctypto');
const nacl = require("tweetnacl");

const message = `${req.rawBody}|${bizTimestamp}`;
const vk = Buffer.from(PUB_KEY, "hex");

const hash2String = CryptoJS.SHA256(CryptoJS.SHA256(message)).toString(CryptoJS.enc.Hex);
try {
    const signatureBuffer = Buffer.from(signature, "hex");
    const messageBuffer = Buffer.from(hash2String, "hex");
    return nacl.sign.detached.verify(
        messageBuffer,
        signatureBuffer,
        vk
    );
} catch (error) {
    console.log("Signature verification failed", error);
    return false;
}
```
</CodeGroup>

<Note>
  **PUB_KEY** 请联系我们获取
</Note>

4. 完整验签示例

<CodeGroup>
``` go title="Go"
package webhook

import (
	"encoding/hex"
	"io"
	"net/http"

	"golang.org/x/crypto/ed25519"
	"crypto/sha256"
	"errors"
)

func VerifySignatureHTTP(w http.ResponseWriter, r *http.Request, pubKeyHex string, rawBody []byte) bool {
	signature := r.Header.Get("biz-resp-signature")
	bizTimestamp := r.Header.Get("biz-timestamp")

	if signature == "" || bizTimestamp == "" {
		http.Error(w, "Missing signature or timestamp", http.StatusUnauthorized)
		return false
	}

	message := string(rawBody) + "|" + bizTimestamp

	h1 := sha256.Sum256([]byte(message))
	h2 := sha256.Sum256(h1[:])
	messageHash := h2[:] // 32 bytes

	sig, err := hex.DecodeString(signature)
	if err != nil {
		http.Error(w, "Invalid signature hex", http.StatusUnauthorized)
		return false
	}

	pubKeyBytes, err := hex.DecodeString(pubKeyHex)
	if err != nil {
		http.Error(w, "Invalid pubkey hex", http.StatusUnauthorized)
		return false
	}

	if len(pubKeyBytes) != ed25519.PublicKeySize || len(sig) != ed25519.SignatureSize {
		http.Error(w, "Invalid key/signature length", http.StatusUnauthorized)
		return false
	}

	if !ed25519.Verify(ed25519.PublicKey(pubKeyBytes), messageHash, sig) {
		http.Error(w, "Invalid signature", http.StatusUnauthorized)
		return false
	}

	return true
}

func ReadRawBody(r *http.Request) ([]byte, error) {
	if r.Body == nil {
		return nil, errors.New("empty body")
	}
	defer r.Body.Close()
	return io.ReadAll(r.Body)
}
```

``` javascript title="Node.js"
const CryptoJS = require('ctypto');
const nacl = require("tweetnacl");

function verifySignature(req, res) {
    const signature = req.headers['biz-resp-signature'];
    const bizTimestamp = req.headers['biz-timestamp'];

    if (!signature || !bizTimestamp) {
        res.status(401).send('Missing signature or timestamp');
        return false;
    }

    const message = `${req.rawBody}|${bizTimestamp}`;

    const vk = Buffer.from(PUB_KEY, "hex");

    const hash2String = CryptoJS.SHA256(CryptoJS.SHA256(message)).toString(CryptoJS.enc.Hex);
    try {
        const signatureBuffer = Buffer.from(signature, "hex");
        const messageBuffer = Buffer.from(hash2String, "hex");
        return nacl.sign.detached.verify(
            messageBuffer,
            signatureBuffer,
            vk
        );
    } catch (error) {
        console.log("Signature verification failed", error);
        return false;
    }

    return true;
}
```
</CodeGroup>

## Webhook 事件

当您的 Webhook Endpoint 收到 Webhook 事件时，它应该响应状态码 200 或 201 以指示事件已成功接收和处理。一旦发送此响应，WaaS 服务将停止重试发送事件，事件状态将变为**已送达**。

默认情况下，每个 Webhook 事件的超时时间为 2 秒。如果 Webhook Endpoint 没有响应或响应状态码不是 200 或 201，WaaS 服务将继续重试发送事件。如果重试次数达到 10 次，WaaS 服务将停止发送事件，事件状态将变为**发送失败**。

NUSD 不保证事件将按生成顺序交付。例如，创建转账将生成以下事件：

- <code>wallets.transaction.created</code>
- <code>wallets.transaction.updated</code>
- <code>wallets.transaction.succeeded</code>

**您的 Endpoint 不应假设事件将按此顺序到达。**

## 实现示例

<CodeGroup>
``` go title="Go"
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"time"

	// "your-module/webhook"
	"io"

	"golang.org/x/crypto/ed25519"
	"crypto/sha256"
	"encoding/hex"
)

const (
	PORT    = "8000"
	PUB_KEY = "YOUR_PUB_KEY_HEX"
)

var walletID = "YOUR_WALLET_ID"

type WebhookPayload struct {
	Data struct {
		WalletID string `json:"wallet_id"`
	} `json:"data"`
}

func verifySignature(w http.ResponseWriter, r *http.Request, rawBody []byte) bool {
	signature := r.Header.Get("biz-resp-signature")
	bizTimestamp := r.Header.Get("biz-timestamp")

	if signature == "" || bizTimestamp == "" {
		http.Error(w, "Missing signature or timestamp", http.StatusUnauthorized)
		return false
	}

	message := string(rawBody) + "|" + bizTimestamp

	h1 := sha256.Sum256([]byte(message))
	h2 := sha256.Sum256(h1[:])
	messageHash := h2[:] // 32 bytes

	sig, err := hex.DecodeString(signature)
	if err != nil {
		http.Error(w, "Invalid signature hex", http.StatusUnauthorized)
		return false
	}

	pubKeyBytes, err := hex.DecodeString(PUB_KEY)
	if err != nil {
		http.Error(w, "Invalid pubkey hex", http.StatusUnauthorized)
		return false
	}

	if len(pubKeyBytes) != ed25519.PublicKeySize || len(sig) != ed25519.SignatureSize {
		http.Error(w, "Invalid key/signature length", http.StatusUnauthorized)
		return false
	}

	if !ed25519.Verify(ed25519.PublicKey(pubKeyBytes), messageHash, sig) {
		http.Error(w, "Invalid signature", http.StatusUnauthorized)
		return false
	}
	return true
}

func webhookHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	_ = ctx

	rawBody, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Read body failed", http.StatusBadRequest)
		return
	}
	defer r.Body.Close()

	if !verifySignature(w, r, rawBody) {
		// verifySignature 已经写回 401
		return
	}

	log.Println(string(rawBody))

	var payload WebhookPayload
	if err := json.Unmarshal(rawBody, &payload); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	// check wallet id
	if payload.Data.WalletID == walletID {
		// Add your business logic here
	}

	// 成功响应 201（或 200）
	w.WriteHeader(http.StatusCreated)
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/api/webhook", webhookHandler)

	srv := &http.Server{
		Addr:         ":" + PORT,
		Handler:      mux,
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 5 * time.Second,
	}

	log.Printf("Server running on http://localhost:%s\n", PORT)
	log.Fatal(srv.ListenAndServe())
}
```

``` javascript title="Node.js"
const express = require("express");

// Express setup
const app = express();
app.use(express.json({
    verify: (req, res, buf) => {
        req.rawBody = buf.toString();
    }
}));

// Webhook endpoint
app.post("/api/webhook", (req, res) => {
    if (!verifySignature(req, res)) {
        res.status(401).send('Invalid signature');
        return;
    }
    const event = req.rawBody;
    console.log(event);

    const datas = JSON.parse(req.rawBody);
    // check wallet id
    if (datas.data.wallet_id == wallet_id) {
        // Add your business logic here
    }

    res.sendStatus(201);
});

// Server startup
const PORT = 8000;
app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});
```
</CodeGroup>