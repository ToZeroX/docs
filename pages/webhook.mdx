---
title: 'Webhook介绍'
---

## Webhook说明

| 机制           | 描述    | 触发条件 | 响应                                                                                    |
|:-----------------|:---------|:----------|:------------------------------------------------------------------------------------------|
| Webhook         | 用作事件的实时通知，例如交易状态更新。  | 当某些事件发生时触发，例如交易状态或 TSS 请求状态更改，基于您订阅的事件类型。       | 以成功状态码（<code>200</code> 或 <code>201</code>）响应。                                                    |

<Note>
  需要在webhook的处理中，判断一下事件中的wallet_id是否为您的wallet_id，如果不是，则忽略。
</Note>

## 处理 webhook 事件

1. 创建一个 webhook
    - 选择服务器环境。
    - 定义Endpoint URL。
2. 在服务器端实现处理逻辑。
    - 解析 API 请求。
    - 验证签名。
    - 响应 API 请求。
    - 添加其他处理逻辑（如果适用）。
3. 将webhook地址提供给我们，由我们来进行配置(暂时)

## 验证签名

为了防止未经授权的访问，当您收到 Webhook 事件时，您需要通过验证签名来验证 API 请求的真实性。

1. 获取请求包体的原始数据和时间戳。 从请求 Payload 中提取包体的原始字符串，并从请求头中提取时间戳。

``` javascript
const bizTimestamp = req.headers['biz-timestamp'];
```

2. 获取签名， 从请求头中获取签名值。

``` javascript
const signature = req.headers['biz-resp-signature'];
```

3. 拼接消息并对其进行哈希处理，使用相应的公钥进行验证：

``` javascript
const CryptoJS = require('ctypto');
const nacl = require("tweetnacl");

const message = `${req.rawBody}|${bizTimestamp}`;
const vk = Buffer.from(PUB_KEY, "hex");

const hash2String = CryptoJS.SHA256(CryptoJS.SHA256(message)).toString(CryptoJS.enc.Hex);
try {
    const signatureBuffer = Buffer.from(signature, "hex");
    const messageBuffer = Buffer.from(hash2String, "hex");
    return nacl.sign.detached.verify(
        messageBuffer,
        signatureBuffer,
        vk
    );
} catch (error) {
    console.log("Signature verification failed", error);
    return false;
}
```

<Note>
  **PUB_KEY** 请联系我们获取
</Note>

4. 完整验签示例

``` javascript
const CryptoJS = require('ctypto');
const nacl = require("tweetnacl");

function verifySignature(req, res) {
    const signature = req.headers['biz-resp-signature'];
    const bizTimestamp = req.headers['biz-timestamp'];

    if (!signature || !bizTimestamp) {
        res.status(401).send('Missing signature or timestamp');
        return false;
    }

    const message = `${req.rawBody}|${bizTimestamp}`;

    const vk = Buffer.from(PUB_KEY, "hex");

    const hash2String = CryptoJS.SHA256(CryptoJS.SHA256(message)).toString(CryptoJS.enc.Hex);
    try {
        const signatureBuffer = Buffer.from(signature, "hex");
        const messageBuffer = Buffer.from(hash2String, "hex");
        return nacl.sign.detached.verify(
            messageBuffer,
            signatureBuffer,
            vk
        );
    } catch (error) {
        console.log("Signature verification failed", error);
        return false;
    }

    return true;
}
```

## Webhook 事件

当您的 Webhook Endpoint 收到 Webhook 事件时，它应该响应状态码 200 或 201 以指示事件已成功接收和处理。一旦发送此响应，WaaS 服务将停止重试发送事件，事件状态将变为**已送达**。

默认情况下，每个 Webhook 事件的超时时间为 2 秒。如果 Webhook Endpoint 没有响应或响应状态码不是 200 或 201，WaaS 服务将继续重试发送事件。如果重试次数达到 10 次，WaaS 服务将停止发送事件，事件状态将变为**发送失败**。

NUSD 不保证事件将按生成顺序交付。例如，创建转账将生成以下事件：

- <code>wallets.transaction.created</code>
- <code>wallets.transaction.updated</code>
- <code>wallets.transaction.succeeded</code>

**您的 Endpoint 不应假设事件将按此顺序到达。**

## Nodejs 实现示例

``` javascript
const express = require("express");

// Express setup
const app = express();
app.use(express.json({
    verify: (req, res, buf) => {
        req.rawBody = buf.toString();
    }
}));

// Webhook endpoint
app.post("/api/webhook", (req, res) => {
    if (!verifySignature(req, res)) {
        res.status(401).send('Invalid signature');
        return;
    }
    const event = req.rawBody;
    console.log(event);

    const datas = JSON.parse(req.rawBody);
    // check wallet id
    if (datas.data.wallet_id == wallet_id) {
        // Add your business logic here
    }

    res.sendStatus(201);
});

// Server startup
const PORT = 8000;
app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});
```

## 字段说明 (webhook收到的内容)

``` json
{
	"event_id": "48bf7cdc-7dd9-4d61-aa61-496003a4787c",
	"url": "https://apidev.nusd.me/webhooks/real",
	"created_timestamp": 1757407060503,
	"type": "wallets.transaction.created", // 重点关注 type: "wallets.transaction.succeeded", 该事件为充值到账
	"data": {
		"transaction_id": "157d3c84-294b-4ca1-8ca7-f0bbb3b98787",
		"wallet_id": "5c8e4ee0-e701-43b8-9724-7815d7c12643",
		"type": "Deposit", // Deposit 为充值
		"status": "Confirming", // status为 "Completed"时，充值到账
		"initiator_type": "External",
		"source": { // 充值来源
			"source_type": "DepositFromAddress",
			"addresses": ["0xf3f42f3d87ac8687b845146ec38aa9672d9669ab"],
			"wallet_id": null,
			"wallet_type": null,
			"wallet_subtype": null
		},
		"destination": { // 充值目标
			"destination_type": "DepositToAddress",
			"amount": "0.001",
			"address": "0x25246af7149a20b2d742b0796431df070eec7048",
			"wallet_id": "5c8e4ee0-e701-43b8-9724-7815d7c12643",
			"wallet_type": "MPC",
			"wallet_subtype": "Org-Controlled",
			"memo": null,
			"tx_info": null
		},
		"created_timestamp": 1757407059769,
		"updated_timestamp": 1757407059770,
		"cobo_id": "20250909163739000102570000001947",
		"request_id": null,
		"sub_status": null,
		"failed_reason": null,
		"chain_id": "TBSC_BNB",
		"token_id": "TBSC_BNB",
		"asset_id": null,
		"result": null,
		"fee": null,
		"initiator": null,
		"confirmed_num": 1,
		"confirming_threshold": 15,
		"transaction_hash": "0x77e1a72d410f279d589b185b4b74d4cc7e030cc67d42c7f0f0d3a96d84c08664",
		"block_info": {
			"block_number": 64752220,
			"block_timestamp": 1757407051000,
			"block_hash": "0xc4dc0d85b266012de8253894ca3a1d0afc06f2814704c1a2dbdbd3006ab2cfdd"
		},
		"raw_tx_info": {
			"used_nonce": 1004,
			"selected_utxos": [],
			"raw_tx": null,
			"unsigned_raw_tx": null,
			"utxo_change": null
		},
		"replacement": null,
		"fueling_info": null,
		"category": [],
		"cobo_category": [],
		"description": "",
		"is_loop": false,
		"extra": null,
		"timeline": [{
			"status": "Confirming",
			"finished": false,
			"finished_timestamp": 1757407059000,
			"sub_status": null
		}],
		"data_type": "Transaction"
	}
}
```

## 重要说明

因为有的链充值到账比较慢，所以 Completed 事件可能不会立即收到，为了不让用户等待过久，所以需要做一下兼容处理，以下两种情况，只要满足其中一种，就可以判断为充值已经到账

  1. 当状态为 <code>Completed</code> 时，用户充值到账
  2. 当 区块确认数 (<code>confirmed_num</code> 字段) >= 10 时，用户充值到账

<Note>
  为什么10个区块后即可认为交易到账？

  在以太坊系列币种（如ETH、GETH）的交易确认中，我们采用了基于Ethereum 2.0升级后Beacon Chain（信标链）的新确认机制。每个区块对应信标链的一个时间槽（Slot），通过信标链的Finalize状态判断交易是否到达终态。这种机制显著降低了区块被分叉回退的概率（已极其罕见），确保交易确认的可靠性。

  确认流程与时间说明：
  - 我们同时检查ETH主链的区块确认数和信标链的Finalize状态。
  - 信标链的Finalize确认相较传统主链确认稍慢，通常需要更多时间。
  - 官方建议的完全确认时间为15-20分钟，相当于约100个区块，以确保交易绝对终态。
  - 但在实际应用中，10个区块后交易被回退的概率已极低，用户侧可认为交易已到账。

  结论：
  10个区块后即可认为交易到账，是因为新确认机制在Beacon Chain的支持下大幅提升了区块稳定性，用户可在此阶段放心认为交易已完成，而100个区块的完全确认则是为了满足更高的确定性需求。
</Note>