---
title: 'Webhook介绍'
---

## Webhook说明

| 机制           | 描述    | 触发条件 | 响应                                                                                    |
|:-----------------|:---------|:----------|:------------------------------------------------------------------------------------------|
| Webhook         | 用作事件的实时通知，例如交易状态更新。  | 当某些事件发生时触发，例如交易状态或 TSS 请求状态更改，基于您订阅的事件类型。       | 以成功状态码（<code>200</code> 或 <code>201</code>）响应。                                                    |

<Note>
  需要在webhook的处理中，判断一下事件中的wallet_id是否为您的wallet_id，如果不是，则忽略。
</Note>

## 处理 webhook 事件

1. 创建一个 webhook
    - 选择服务器环境。
    - 定义Endpoint URL。
2. 在服务器端实现处理逻辑。
    - 解析 API 请求。
    - 验证签名。
    - 响应 API 请求。
    - 添加其他处理逻辑（如果适用）。
3. 将webhook地址提供给我们，由我们来进行配置(暂时)

## 验证签名

为了防止未经授权的访问，当您收到 Webhook 事件时，您需要通过验证签名来验证 API 请求的真实性。

1. 获取请求包体的原始数据和时间戳。 从请求 Payload 中提取包体的原始字符串，并从请求头中提取时间戳。

``` javascript
const bizTimestamp = req.headers['biz-timestamp'];
```

2. 获取签名， 从请求头中获取签名值。

``` javascript
const signature = req.headers['biz-resp-signature'];
```

3. 拼接消息并对其进行哈希处理，使用相应的公钥进行验证：

``` javascript
const CryptoJS = require('ctypto');
const nacl = require("tweetnacl");

const message = `${req.rawBody}|${bizTimestamp}`;
const vk = Buffer.from(PUB_KEY, "hex");

const hash2String = CryptoJS.SHA256(CryptoJS.SHA256(message)).toString(CryptoJS.enc.Hex);
try {
    const signatureBuffer = Buffer.from(signature, "hex");
    const messageBuffer = Buffer.from(hash2String, "hex");
    return nacl.sign.detached.verify(
        messageBuffer,
        signatureBuffer,
        vk
    );
} catch (error) {
    console.log("Signature verification failed", error);
    return false;
}
```

<Note>
  **PUB_KEY** 请联系我们获取
</Note>

4. 完整验签示例

``` javascript
const CryptoJS = require('ctypto');
const nacl = require("tweetnacl");

function verifySignature(req, res) {
    const signature = req.headers['biz-resp-signature'];
    const bizTimestamp = req.headers['biz-timestamp'];

    if (!signature || !bizTimestamp) {
        res.status(401).send('Missing signature or timestamp');
        return false;
    }

    const message = `${req.rawBody}|${bizTimestamp}`;

    const vk = Buffer.from(PUB_KEY, "hex");

    const hash2String = CryptoJS.SHA256(CryptoJS.SHA256(message)).toString(CryptoJS.enc.Hex);
    try {
        const signatureBuffer = Buffer.from(signature, "hex");
        const messageBuffer = Buffer.from(hash2String, "hex");
        return nacl.sign.detached.verify(
            messageBuffer,
            signatureBuffer,
            vk
        );
    } catch (error) {
        console.log("Signature verification failed", error);
        return false;
    }

    return true;
}
```

## Webhook 事件

当您的 Webhook Endpoint 收到 Webhook 事件时，它应该响应状态码 200 或 201 以指示事件已成功接收和处理。一旦发送此响应，WaaS 服务将停止重试发送事件，事件状态将变为**已送达**。

默认情况下，每个 Webhook 事件的超时时间为 2 秒。如果 Webhook Endpoint 没有响应或响应状态码不是 200 或 201，WaaS 服务将继续重试发送事件。如果重试次数达到 10 次，WaaS 服务将停止发送事件，事件状态将变为**发送失败**。

NUSD 不保证事件将按生成顺序交付。例如，创建转账将生成以下事件：

- <code>wallets.transaction.created</code>
- <code>wallets.transaction.updated</code>
- <code>wallets.transaction.succeeded</code>

**您的 Endpoint 不应假设事件将按此顺序到达。**

## Nodejs 实现示例

``` javascript
const express = require("express");

// Express setup
const app = express();
app.use(express.json({
    verify: (req, res, buf) => {
        req.rawBody = buf.toString();
    }
}));

// Webhook endpoint
app.post("/api/webhook", (req, res) => {
    if (!verifySignature(req, res)) {
        res.status(401).send('Invalid signature');
        return;
    }
    const event = req.rawBody;
    console.log(event);

    const datas = JSON.parse(req.rawBody);
    // check wallet id
    if (datas.data.wallet_id == wallet_id) {
        // Add your business logic here
    }

    res.sendStatus(201);
});

// Server startup
const PORT = 8000;
app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});
```